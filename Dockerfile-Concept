üê≥ What is a Dockerfile?
A Dockerfile is a text file that contains instructions used by Docker to build a Docker image. These instructions define everything needed to create and run a container ‚Äî like the operating system, application code, dependencies, configurations, and commands.
________________________________________
üìò Basic Syntax of a Dockerfile
    A Dockerfile is written in a line-by-line instruction format. Each line has a Dockerfile directive (command) and its corresponding arguments.
    Here's the general structure:
        INSTRUCTION arguments
________________________________________
‚úÖ Mandatory Dockerfile Components
    At minimum, to create a functional Docker image, a Dockerfile must include:
    1.	FROM ‚Äî defines base image
    2.	CMD or ENTRYPOINT ‚Äî defines what to run
        Now, let's go step-by-step üëá
________________________________________
üîß Step-by-Step Instructions
________________________________________
1. FROM ‚Äî Base Image
    ‚Ä¢	Purpose: Sets the base image your Docker image builds upon.
    ‚Ä¢	Mandatory: ‚úÖ YES
    FROM ubuntu:20.04
    ‚Ä¢	You can use official images like ubuntu, node, python, etc.
    ‚Ä¢	You can use a custom image as a base.
    ‚Ä¢	Always specify the tag/version to avoid using the latest unknowingly.
    üìå You can have multiple FROM statements in advanced scenarios (called multi-stage builds).
________________________________________
2. LABEL ‚Äî Metadata
    ‚Ä¢	Purpose: Adds metadata (like maintainer, version).
    ‚Ä¢	Mandatory: ‚ùå NO
    LABEL maintainer="yourname@example.com"
    LABEL version="1.0"
    Useful for identifying and documenting your image.
________________________________________
3. ENV ‚Äî Environment Variables
    ‚Ä¢	Purpose: Sets environment variables.
    ‚Ä¢	Mandatory: ‚ùå NO
    ENV APP_HOME=/usr/src/app
    Helps to avoid hardcoding values. Can be used later in the Dockerfile as $APP_HOME.
________________________________________
4. WORKDIR ‚Äî Working Directory
    ‚Ä¢	Purpose: Sets the working directory for subsequent instructions (RUN, CMD, COPY, etc.)
    ‚Ä¢	Mandatory: ‚ùå NO (but recommended)
    WORKDIR /usr/src/app
    Avoids using cd in RUN and makes the image more maintainable.
________________________________________
5. COPY / ADD ‚Äî Adding Files
    ‚Ä¢	Purpose: Copies files from your host into the image.
    ‚Ä¢	Mandatory: ‚ùå NO (but needed to include app code)
    COPY . .
    # OR
    COPY requirements.txt .
    
    # Optional:
    # ADD myarchive.tar.gz /app/
    ‚úÖ Prefer COPY over ADD unless you need:
    ‚Ä¢	Remote URLs
    ‚Ä¢	Automatic extraction of .tar.gz files
________________________________________
6. RUN ‚Äî Execute Commands During Build
    ‚Ä¢	Purpose: Executes commands at build time to modify the image.
    ‚Ä¢	Mandatory: ‚ùå NO (but usually used to install packages)
    RUN apt-get update && apt-get install -y python3 python3-pip
    RUN pip install -r requirements.txt
    Each RUN creates a new layer in the image. Combine commands to reduce layers.
________________________________________
7. EXPOSE ‚Äî Document Port
    ‚Ä¢	Purpose: Informs Docker which port the container will listen on.
    ‚Ä¢	Mandatory: ‚ùå NO
    EXPOSE 5000
    Does not actually open the port. It‚Äôs informational for people/tools.
________________________________________
8. CMD ‚Äî Default Command
    ‚Ä¢	Purpose: Defines the default command to run when a container starts.
    ‚Ä¢	Mandatory: ‚úÖ YES (or use ENTRYPOINT)
    CMD ["python3", "app.py"]
    ‚Ä¢	Can be written as JSON array (exec form, recommended) or as a shell string:
    CMD python3 app.py
    üìå Only one CMD is allowed. Later ones override earlier.
________________________________________
9. ENTRYPOINT ‚Äî Fixed Command
    ‚Ä¢	Purpose: Sets the main command, but allows additional arguments via CMD or CLI.
    ‚Ä¢	Mandatory: ‚ùå NO (but powerful)
    ENTRYPOINT ["python3", "app.py"]
    ‚Ä¢	Combine with CMD to set default args:
    ENTRYPOINT ["python3", "app.py"]
    CMD ["--port", "5000"]
    Now you can override CMD at runtime:
    docker run myapp --port 8080
________________________________________
10. VOLUME ‚Äî Define a mount point
    ‚Ä¢	Purpose: Declares a volume for persistent data.
    ‚Ä¢	Mandatory: ‚ùå NO
    VOLUME /data
    Useful for storing logs, DB data, etc.
________________________________________
11. USER ‚Äî Set the user
    ‚Ä¢	Purpose: Switches from root to a less privileged user.
    ‚Ä¢	Mandatory: ‚ùå NO (but improves security)
    USER appuser
________________________________________
12. ARG ‚Äî Build-time Variables
    ‚Ä¢	Purpose: Pass variables at build time.
    ‚Ä¢	Mandatory: ‚ùå NO
    ARG VERSION=1.0
    RUN echo $VERSION
    Pass values via:
    docker build --build-arg VERSION=2.0 .
________________________________________
13. HEALTHCHECK ‚Äî Container Health Check
    ‚Ä¢	Purpose: Tells Docker how to test if your app is healthy.
    ‚Ä¢	Mandatory: ‚ùå NO
    HEALTHCHECK CMD curl --fail http://localhost:5000/health || exit 1

________________________________________

üöÄ Dockerfiles for Different Stacks
________________________________________
1Ô∏è‚É£ Python Dockerfile

Typical for Python apps like Flask, Django, or any Python script.    
    # Use official Python base image
    FROM python:3.11-slim
    # Set working directory
    WORKDIR /app
    # Copy requirements and install dependencies
    COPY requirements.txt .
    RUN pip install --no-cache-dir -r requirements.txt
    # Copy app code
    COPY . .
    # Expose the port your app listens on (example 5000 for Flask)
    EXPOSE 5000
    # Run the app
    CMD ["python", "app.py"]
________________________________________‚ÄÉ
2Ô∏è‚É£ Node.js Dockerfile

For Node.js apps (Express, React SSR, etc).
    # Use official Node.js base image
    FROM node:18-alpine
    # Set working directory
    WORKDIR /usr/src/app
    # Copy package files and install dependencies
    COPY package*.json ./
    RUN npm install --production
    # Copy app code
    COPY . .
    # Expose app port (example 3000)
    EXPOSE 3000
    # Run the app
    CMD ["node", "server.js"]
________________________________________
3Ô∏è‚É£ Java Dockerfile
For Java apps, typically built using Maven or Gradle and run with java -jar.
    # Use official OpenJDK image
    FROM openjdk:17-jdk-slim
    # Copy the jar file from host to image
    COPY target/myapp.jar /app/myapp.jar
    # Expose port (e.g., 8080)
    EXPOSE 8080
    # Run the jar file
    CMD ["java", "-jar", "/app/myapp.jar"]
________________________________________
üõ†Ô∏è Using Custom Manually Created Base Images

If you want to use your own custom base image (instead of official ones), here's how to do it:    
    1. Build your custom base image first
        Suppose you create a base image for your stack:
        # My custom base image for Python
        FROM ubuntu:20.04
        RUN apt-get update && apt-get install -y python3 python3-pip
        Build it:
        docker build -t my-custom-python-base:1.0 .
    
    2. Use your custom base image in your app's Dockerfile
    # Use your custom base image
        FROM my-custom-python-base:1.0
        WORKDIR /app
        COPY requirements.txt .
        RUN pip3 install --no-cache-dir -r requirements.txt
        COPY . .
        EXPOSE 5000
        CMD ["python3", "app.py"]
________________________________________
üß† Important notes when using custom base images

    ‚Ä¢	Tag your custom image properly (e.g., mybaseimage:v1).
    ‚Ä¢	If your custom base image is stored in a private registry, you may need to configure Docker login to pull it.
    ‚Ä¢	Custom base images let you pre-install tools or configure the environment your apps need, so you don‚Äôt repeat it in every app Dockerfile.
________________________________________
Bonus: Multi-Stage Builds (Advanced)

To keep your images small, you can build in stages.
Example: Java multi-stage
    # Build stage
    FROM maven:3.8.6-openjdk-17 AS build
    WORKDIR /app
    COPY pom.xml .
    COPY src ./src
    RUN mvn package -DskipTests
    
    # Run stage
    FROM openjdk:17-jdk-slim
    COPY --from=build /app/target/myapp.jar /app/myapp.jar
    EXPOSE 8080
    CMD ["java", "-jar", "/app/myapp.jar"]


_________________________________________
üê≥ Dockerfile for Nginx
Basic Nginx Dockerfile ‚Äî Installing from Official Image (Recommended way)
Usually, you don‚Äôt install Nginx yourself in a base OS; you just start from the official Nginx image, which is slim and optimized.
    # Start from official nginx image
    FROM nginx:stable-alpine
    # Copy your custom nginx config file (optional)
    COPY nginx.conf /etc/nginx/nginx.conf
    # Copy static content (optional)
    COPY ./html /usr/share/nginx/html
    # Expose port 80
    EXPOSE 80
    # Start Nginx (already configured in the base image CMD)
    CMD ["nginx", "-g", "daemon off;"]
________________________________________
If you want to install Nginx yourself on a base OS (not recommended)
    FROM ubuntu:22.04
    # Install nginx
    RUN apt-get update && apt-get install -y nginx \  && rm -rf /var/lib/apt/lists/*
    # Copy your custom nginx config if needed
    COPY nginx.conf /etc/nginx/nginx.conf
    # Expose port 80
    EXPOSE 80
    # Run nginx in the foreground
    CMD ["nginx", "-g", "daemon off;"]
________________________________________
üê≥ Dockerfile for HAProxy
Using Official HAProxy Image (Recommended)
    FROM haproxy:2.8-alpine
    # Copy custom haproxy config
    COPY haproxy.cfg /usr/local/etc/haproxy/haproxy.cfg
    # Expose ports (e.g., 80 and 443)
    EXPOSE 80 443
    # Run HAProxy (default CMD in the base image)
    CMD ["haproxy", "-f", "/usr/local/etc/haproxy/haproxy.cfg"]
________________________________________
Installing HAProxy from a base OS (Ubuntu example)
    FROM ubuntu:22.04
    RUN apt-get update && apt-get install -y haproxy \ && rm -rf /var/lib/apt/lists/*
    COPY haproxy.cfg /etc/haproxy/haproxy.cfg
    EXPOSE 80 443
    CMD ["haproxy", "-f", "/etc/haproxy/haproxy.cfg"]
________________________________________
üîë Key Points
    ‚Ä¢	Always prefer official images like nginx, haproxy ‚Äî they are optimized, smaller, and maintained.
    ‚Ä¢	Copy your custom config files into the image, replacing defaults.
    ‚Ä¢	Use EXPOSE for ports your proxy listens on.
    ‚Ä¢	Use CMD or rely on the base image‚Äôs default command to run the service in the foreground (daemon off for nginx).
    ‚Ä¢	Clean up package caches after installation to reduce image size (rm -rf /var/lib/apt/lists/*).
________________________________________
Example: Simple Nginx Dockerfile with custom config
    FROM nginx:alpine
    COPY nginx.conf /etc/nginx/nginx.conf
    EXPOSE 80
    CMD ["nginx", "-g", "daemon off;"]

________________________________________

Understanding CMD and Passing Flags/Arguments in Dockerfile
________________________________________
1Ô∏è‚É£ What is CMD in Dockerfile?
    ‚Ä¢	The CMD instruction specifies the default command and its arguments that will run when a container starts from the image.
    ‚Ä¢	It can be written in two forms:
    o	Shell form (runs in /bin/sh -c):
    o	CMD nginx -g 'daemon off;'
    o	Exec form (preferred, runs as a direct process):
    o	CMD ["nginx", "-g", "daemon off;"]
    ‚Ä¢	The exec form uses a JSON array where each element is a separate token ‚Äî command and its arguments.
________________________________________
2Ô∏è‚É£ How do flags like -g and -f work here?
    ‚Ä¢	Flags like -g (Nginx) or -f (HAProxy) are command-line options passed to the main executable.
    ‚Ä¢	Example:
    ‚Ä¢	CMD ["nginx", "-g", "daemon off;"]
    o	Runs the nginx binary with the -g flag.
    o	-g "daemon off;" tells Nginx to run in the foreground (i.e., don‚Äôt daemonize), which is important inside containers.
    ‚Ä¢	Similarly, for HAProxy:
    ‚Ä¢	CMD ["haproxy", "-f", "/usr/local/etc/haproxy/haproxy.cfg"]
    o	Runs haproxy with the -f flag specifying the config file to use.
________________________________________
3Ô∏è‚É£ Why pass flags in CMD?
    ‚Ä¢	Containers usually expect the main process to run in the foreground.
    ‚Ä¢	Flags like -g daemon off; (Nginx) or specifying config files (HAProxy) control how the service runs.
    ‚Ä¢	This ensures that Docker can manage the lifecycle of the container properly.
________________________________________
4Ô∏è‚É£ How to define these flags in CMD for any service or stack?
General rule:
    ‚Ä¢	Use the exec form of CMD for clarity and reliability.
    ‚Ä¢	Provide the executable and all required arguments as separate array elements.
    Example:
    CMD ["<executable>", "<flag1>", "<flag2>", "<value>", ...]
For different stacks:
    Stack	Example CMD with flags	Explanation
    Nginx	["nginx", "-g", "daemon off;"]	Run Nginx in foreground
    HAProxy	["haproxy", "-f", "/path/to/haproxy.cfg"]	Use custom HAProxy config file
    Python	["python", "app.py", "--port", "5000"]	Pass arguments to Python script
    Node.js	["node", "server.js", "--env", "production"]	Pass CLI args to Node app
    Java	["java", "-jar", "app.jar", "--spring.profiles.active=prod"]	Pass Java app args
________________________________________
5Ô∏è‚É£ What if I want to override or pass runtime args?
    ‚Ä¢	You can override the CMD arguments when running the container:
docker run <image> <new-command-or-args>
    ‚Ä¢	Example overriding Nginx command:
docker run my-nginx nginx -g "daemon off;" -c /custom/nginx.conf
